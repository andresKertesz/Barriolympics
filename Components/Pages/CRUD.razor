@typeparam TEntity where TEntity : class, new()
@using System.Reflection
@using System.ComponentModel.DataAnnotations
@using System.ComponentModel.DataAnnotations.Schema
@using System.Linq.Expressions
@using BarriolympicsRadzen.Data
@using Microsoft.EntityFrameworkCore
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject DialogService DialogService
@inject NotificationService NotificationService
@inject IJSRuntime JSRuntime

<div class="container">
    <h3>@EntityName Management</h3>

    <RadzenButton Text="@($"Add New {EntityName}")" ButtonStyle="ButtonStyle.Success"
                  Class="mt-2 mb-4" Click="@(() => OpenEditDialog(new TEntity()))" />

    <RadzenDataGrid @ref="grid" AllowFiltering="true" AllowColumnResize="true"
                    AllowAlternatingRows="false" FilterMode="FilterMode.Advanced" AllowSorting="true"
                    PageSize="10" AllowPaging="true" PagerHorizontalAlign="HorizontalAlign.Left"
                    ShowPagingSummary="true" Data="@entities" TItem="TEntity" ColumnWidth="300px"
                    RowSelect="@OnRowSelect">
        <Columns>
            @foreach (var property in DisplayProperties)
            {
                <RadzenDataGridColumn TItem="TEntity" Property="@property.Name" Title="@GetDisplayName(property)"
                                      Width="@GetColumnWidth(property)" Filterable="@IsFilterable(property)"
                                      Sortable="@IsSortable(property)" FormatString="@GetFormatString(property)">
                    <Template Context="data">
                        @GetFormattedValue(data, property)
                    </Template>
                </RadzenDataGridColumn>
            }
            <RadzenDataGridColumn TItem="TEntity" Context="data" Filterable="false" Sortable="false"
                                  TextAlign="TextAlign.Center" Width="120px">
                <Template Context="data">
                    <RadzenButton Icon="edit" ButtonStyle="ButtonStyle.Light" Class="m-1"
                                  Click="@(args => OpenEditDialog(data))" @onclick:stopPropagation="true" />
                    <RadzenButton Icon="delete" ButtonStyle="ButtonStyle.Danger" Class="m-1"
                                  Click="@(args => DeleteEntity(data))" @onclick:stopPropagation="true" />
                </Template>
            </RadzenDataGridColumn>
        </Columns>
    </RadzenDataGrid>
</div>

@code {
    private RadzenDataGrid<TEntity> grid;
    private List<TEntity> entities = new List<TEntity>();
    private List<PropertyInfo> allProperties;
    private List<PropertyInfo> displayProperties;
    private PropertyInfo keyProperty;

    [Parameter]
    public string Title { get; set; }

    [Parameter]
    public Expression<Func<ApplicationDbContext, DbSet<TEntity>>> DbSetSelector { get; set; }

    [Parameter]
    public string[] ExcludeProperties { get; set; } = Array.Empty<string>();

    [Parameter]
    public string[] ReadOnlyProperties { get; set; } = Array.Empty<string>();

    private string EntityName => typeof(TEntity).Name;

    private List<PropertyInfo> DisplayProperties => displayProperties ??= GetDisplayProperties();

    protected override async Task OnInitializedAsync()
    {
        allProperties = typeof(TEntity).GetProperties().ToList();
        keyProperty = allProperties.FirstOrDefault(p => p.GetCustomAttribute<KeyAttribute>() != null);

        await LoadData();
    }

    private async Task LoadData()
    {
        await using var context = await DbFactory.CreateDbContextAsync();
        var dbSet = DbSetSelector.Compile()(context);

        // Load entities with related entities
        var query = dbSet.AsQueryable();

        // Include navigation properties that are reference types
        foreach (var property in allProperties.Where(p =>
            p.PropertyType.IsClass &&
            p.PropertyType != typeof(string) &&
            !p.PropertyType.IsArray &&
            !p.GetCustomAttributes<NotMappedAttribute>().Any()))
        {
            query = query.Include(property.Name);
        }

        entities = await query.ToListAsync();
    }

    private List<PropertyInfo> GetDisplayProperties()
    {
        return allProperties
            .Where(p => !p.GetCustomAttributes<NotMappedAttribute>().Any())
            .Where(p => !ExcludeProperties.Contains(p.Name))
            .Where(p => !IsComplexCollection(p))
            .ToList();
    }

    private bool IsComplexCollection(PropertyInfo property)
    {
        return property.PropertyType.IsGenericType &&
               property.PropertyType.GetGenericTypeDefinition() == typeof(ICollection<>) &&
               property.PropertyType.GetGenericArguments()[0].IsClass &&
               property.PropertyType.GetGenericArguments()[0] != typeof(string);
    }

    private bool IsFilterable(PropertyInfo property)
    {
        var type = Nullable.GetUnderlyingType(property.PropertyType) ?? property.PropertyType;
        return type == typeof(string) ||
               type == typeof(int) ||
               type == typeof(decimal) ||
               type == typeof(double) ||
               type == typeof(float) ||
               type == typeof(DateTime) ||
               type == typeof(bool);
    }

    private bool IsSortable(PropertyInfo property)
    {
        var type = Nullable.GetUnderlyingType(property.PropertyType) ?? property.PropertyType;
        return type == typeof(string) ||
               type == typeof(int) ||
               type == typeof(decimal) ||
               type == typeof(double) ||
               type == typeof(float) ||
               type == typeof(DateTime) ||
               type == typeof(bool);
    }

    private string GetDisplayName(PropertyInfo property)
    {
        var displayAttr = property.GetCustomAttribute<DisplayAttribute>();
        return displayAttr?.Name ?? SplitCamelCase(property.Name);
    }

    private string GetColumnWidth(PropertyInfo property)
    {
        var type = Nullable.GetUnderlyingType(property.PropertyType) ?? property.PropertyType;

        if (type == typeof(bool)) return "120px";
        if (type == typeof(int) || type == typeof(decimal) || type == typeof(double) || type == typeof(float)) return "150px";
        if (type == typeof(DateTime)) return "180px";

        return "200px";
    }

    private string GetFormatString(PropertyInfo property)
    {
        var type = Nullable.GetUnderlyingType(property.PropertyType) ?? property.PropertyType;

        if (type == typeof(decimal) || type == typeof(double) || type == typeof(float)) return "{0:N2}";
        if (type == typeof(DateTime)) return "{0:d}";

        return null;
    }

    private object GetFormattedValue(TEntity entity, PropertyInfo property)
    {
        var value = property.GetValue(entity);

        if (value == null) return null;

        // If it's a navigation property, display meaningful info
        if (property.PropertyType.IsClass && property.PropertyType != typeof(string) && !property.PropertyType.IsArray)
        {
            var navEntity = value;
            var displayProp = navEntity.GetType().GetProperties()
                .FirstOrDefault(p => p.Name == "Name" || p.Name == "Title" || p.Name == "Nombre");

            if (displayProp != null)
            {
                return displayProp.GetValue(navEntity)?.ToString();
            }

            return "[Complex Object]";
        }

        return value;
    }

    private void OnRowSelect(TEntity entity)
    {
        OpenEditDialog(entity);
    }

    private async Task DeleteEntity(TEntity entity)
    {
        if (!await JSRuntime.InvokeAsync<bool>("confirm", $"Are you sure you want to delete this {EntityName}?"))
        {
            return;
        }

        await using var context = await DbFactory.CreateDbContextAsync();
        var dbSet = DbSetSelector.Compile()(context);

        if (keyProperty != null)
        {
            // If we have a key property, use it to find the entity
            var keyValue = keyProperty.GetValue(entity);
            var entityToDelete = await dbSet.FindAsync(keyValue);
            if (entityToDelete != null)
            {
                dbSet.Remove(entityToDelete);
                await context.SaveChangesAsync();
                await LoadData();
                NotificationService.Notify(NotificationSeverity.Success, "Success", $"{EntityName} was deleted successfully.");
            }
        }
        else
        {
            // If no key property found, try to remove directly
            dbSet.Remove(entity);
            await context.SaveChangesAsync();
            await LoadData();
            NotificationService.Notify(NotificationSeverity.Success, "Success", $"{EntityName} was deleted successfully.");
        }
    }

    private async Task OpenEditDialog(TEntity entity)
    {
        var isNew = keyProperty != null && keyProperty.GetValue(entity) == null;

        var result = await DialogService.OpenAsync<GenericEditDialog<TEntity>>(
            $"{(isNew ? "Add" : "Edit")} {EntityName}",
            new Dictionary<string, object>
                {
                { "Entity", entity },
                { "DbSetSelector", DbSetSelector },
                { "ExcludeProperties", ExcludeProperties },
                { "ReadOnlyProperties", ReadOnlyProperties }
                },
            new DialogOptions
                {
                    Width = "700px",
                    Height = "auto",
                    CloseDialogOnEsc = false,
                    CloseDialogOnOverlayClick = false
                });

        if (result != null)
        {
            await LoadData();
        }
    }

    private string SplitCamelCase(string input)
    {
        if (string.IsNullOrEmpty(input)) return input;

        var result = new System.Text.StringBuilder();
        result.Append(input[0]);

        for (var i = 1; i < input.Length; i++)
        {
            if (char.IsUpper(input[i]))
            {
                result.Append(' ');
            }
            result.Append(input[i]);
        }

        return result.ToString();
    }
}